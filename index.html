<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>MemoryFreedom</title>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTWVtb3J5RnJlZWRvbSIsInNob3J0X25hbWUiOiJNZW1vcnlGcmVlZG9tIiwic3RhcnRfdXJsIjoiLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAwMDAiLCJ0aGVtZV9jb2xvciI6IiMwMGQ5ZmYiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJyUzRSUzQ3JlY3QgZmlsbD0nJTIzMDBkOWZmJyB3aWR0aD0nMTAwJyBoZWlnaHQ9JzEwMCcgcng9JzIwJy8lM0UlM0N0ZXh0IHg9JzUwJyB5PSc3MCcgZm9udC1zaXplPSc2MCcgdGV4dC1hbmNob3I9J21pZGRsZScgZmlsbD0nJTIzMDAwJyUzRSVGMCU5RiU5MyVBNiUzQy90ZXh0JTNFJTNDL3N2ZyUzRSIsInNpemVzIjoiNTEyeDUxMiIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #000; --bg2: #1a1a1a; --bg3: #2a2a2a;
            --text: #fff; --text2: #a0a0a0;
            --accent: #00d9ff; --success: #00ff88; --error: #ff4444;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg); color: var(--text);
            overflow-x: hidden; -webkit-font-smoothing: antialiased;
        }

```
    /* Loading Screen */
    #loading {
        position: fixed; inset: 0; background: var(--bg);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        z-index: 9999; transition: opacity 0.3s;
    }
    #loading.hide { opacity: 0; pointer-events: none; }
    .spinner {
        width: 50px; height: 50px;
        border: 3px solid var(--bg3); border-top-color: var(--accent);
        border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loading-text { margin-top: 20px; color: var(--text2); }
    
    /* Login Screen */
    #login {
        position: fixed; inset: 0; background: var(--bg);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        padding: 20px; z-index: 9998;
    }
    #login.hide { display: none; }
    #login h1 {
        font-size: 32px; font-weight: 700; margin-bottom: 8px;
        background: linear-gradient(135deg, var(--accent), var(--success));
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    #login p { color: var(--text2); margin-bottom: 32px; }
    .login-form { width: 100%; max-width: 400px; }
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; font-size: 14px; color: var(--text2); margin-bottom: 8px; }
    .form-input {
        width: 100%; background: var(--bg2); border: 1px solid var(--bg3);
        border-radius: 12px; padding: 14px; color: var(--text);
        font-size: 16px; outline: none; transition: 0.2s;
    }
    .form-input:focus { border-color: var(--accent); }
    .btn {
        padding: 14px 24px; border: none; border-radius: 12px;
        font-size: 16px; font-weight: 600; cursor: pointer;
        transition: 0.2s; width: 100%; margin-bottom: 12px;
    }
    .btn-primary { background: var(--accent); color: var(--bg); }
    .btn-primary:active { opacity: 0.8; }
    .btn-secondary {
        background: var(--bg2); color: var(--text); border: 1px solid var(--bg3);
    }
    
    /* Header */
    .header {
        position: sticky; top: 0; background: var(--bg);
        border-bottom: 1px solid var(--bg3); padding: 16px 20px; z-index: 100;
    }
    .header h1 {
        font-size: 24px; font-weight: 700;
        background: linear-gradient(135deg, var(--accent), var(--success));
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .status {
        display: inline-flex; align-items: center; gap: 6px;
        padding: 4px 12px; background: var(--bg2); border-radius: 12px;
        font-size: 12px; margin-top: 8px;
    }
    .dot { width: 8px; height: 8px; border-radius: 50%; }
    .dot.synced { background: var(--success); }
    .dot.syncing { background: var(--accent); animation: pulse 1s infinite; }
    .dot.error { background: var(--error); }
    @keyframes pulse { 50% { opacity: 0.5; } }
    
    /* Tabs */
    .tabs {
        display: flex; gap: 4px; padding: 12px 20px;
        background: var(--bg); border-bottom: 1px solid var(--bg3); overflow-x: auto;
    }
    .tab {
        flex: 1; padding: 12px; background: transparent; border: none;
        color: var(--text2); font-size: 14px; font-weight: 500;
        border-radius: 8px; cursor: pointer; transition: 0.2s; white-space: nowrap;
    }
    .tab.active { background: var(--bg3); color: var(--accent); }
    
    .content { display: none; padding: 20px; min-height: calc(100vh - 140px); }
    .content.active { display: block; }
    
    /* Search & Chips */
    .search {
        display: flex; align-items: center; gap: 8px;
        background: var(--bg2); border-radius: 12px; padding: 12px 16px; margin-bottom: 16px;
    }
    .search input {
        flex: 1; background: none; border: none;
        color: var(--text); font-size: 16px; outline: none;
    }
    .chips { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 12px; margin-bottom: 16px; }
    .chip {
        padding: 8px 16px; background: var(--bg2); border: 1px solid var(--bg3);
        border-radius: 20px; color: var(--text2); font-size: 14px;
        white-space: nowrap; cursor: pointer; transition: 0.2s;
    }
    .chip.active { background: var(--accent); color: var(--bg); border-color: var(--accent); }
    
    /* Item Card */
    .item {
        background: var(--bg2); border-radius: 12px; padding: 16px;
        margin-bottom: 12px; cursor: pointer; transition: transform 0.2s;
    }
    .item:active { transform: scale(0.98); }
    .item-content { display: flex; gap: 12px; }
    .item-img {
        width: 60px; height: 60px; border-radius: 8px;
        object-fit: cover; background: var(--bg3); flex-shrink: 0;
    }
    .item-img.placeholder {
        display: flex; align-items: center; justify-content: center;
        color: var(--text2); font-size: 24px;
    }
    .item-info { flex: 1; min-width: 0; }
    .item-name { font-weight: 600; margin-bottom: 4px; }
    .item-cat { font-size: 12px; color: var(--text2); margin-bottom: 4px; }
    .item-notes {
        font-size: 12px; color: var(--text2);
        overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    
    /* Modal */
    .modal {
        position: fixed; inset: 0; background: rgba(0,0,0,0.9);
        z-index: 1000; display: none; padding: 20px; overflow-y: auto;
    }
    .modal.show { display: block; }
    .modal-content {
        background: var(--bg2); border-radius: 16px;
        padding: 24px; max-width: 500px; margin: 40px auto;
    }
    .modal-header {
        display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;
    }
    .modal-title { font-size: 20px; font-weight: 700; }
    .modal-close {
        background: none; border: none; color: var(--text2);
        font-size: 24px; cursor: pointer; padding: 0; width: 32px; height: 32px;
    }
    .form-textarea {
        width: 100%; background: var(--bg3); border: 1px solid transparent;
        border-radius: 8px; padding: 12px; color: var(--text);
        font-size: 16px; outline: none; transition: 0.2s;
        min-height: 100px; resize: vertical; font-family: inherit;
    }
    .form-textarea:focus { border-color: var(--accent); }
    
    /* Empty State */
    .empty { text-align: center; padding: 60px 20px; }
    .empty-icon { font-size: 60px; margin-bottom: 16px; opacity: 0.3; }
    .empty-title { font-size: 18px; font-weight: 600; margin-bottom: 8px; }
    .empty-text { color: var(--text2); font-size: 14px; }
    
    /* Chat */
    .chat { display: flex; flex-direction: column; gap: 16px; padding-bottom: 80px; }
    .bubble { max-width: 80%; padding: 12px 16px; border-radius: 16px; word-wrap: break-word; }
    .bubble.user { align-self: flex-end; background: var(--accent); color: var(--bg); }
    .bubble.assistant { align-self: flex-start; background: var(--bg2); }
    .chat-input-bar {
        position: fixed; bottom: 0; left: 0; right: 0;
        background: var(--bg); border-top: 1px solid var(--bg3);
        padding: 12px 20px; display: flex; gap: 12px;
    }
    .chat-input {
        flex: 1; background: var(--bg2); border: none; border-radius: 20px;
        padding: 12px 16px; color: var(--text); font-size: 16px; outline: none;
    }
    .chat-send {
        width: 44px; height: 44px; border-radius: 50%;
        background: var(--accent); border: none; color: var(--bg);
        font-size: 20px; cursor: pointer; display: flex;
        align-items: center; justify-content: center;
    }
    .chat-send:disabled { opacity: 0.5; }
    
    /* Settings */
    .settings-section { margin-bottom: 32px; }
    .settings-title {
        font-size: 14px; color: var(--text2);
        text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;
    }
    .settings-item {
        background: var(--bg2); border-radius: 12px; padding: 16px;
        margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
    }
    .btn-danger { background: var(--error); color: white; }
    
    /* FAB */
    .fab {
        position: fixed; bottom: 80px; right: 20px;
        width: 56px; height: 56px; border-radius: 50%;
        background: var(--accent); color: var(--bg); border: none;
        font-size: 24px; box-shadow: 0 4px 12px rgba(0,217,255,0.3);
        cursor: pointer; z-index: 100; display: flex;
        align-items: center; justify-content: center;
    }
    .fab:active { transform: scale(0.95); }
    
    .hide { display: none !important; }
    .mt { margin-top: 16px; }
</style>
```

</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <p id="loading-text">Loading MemoryFreedom...</p>
    </div>

```
<!-- Login Screen -->
<div id="login">
    <h1>MemoryFreedom</h1>
    <p>Your encrypted personal storage system</p>
    <div class="login-form">
        <div class="form-group">
            <label class="form-label">Your Name (Dad, Mom, Alice, etc.)</label>
            <input type="text" class="form-input" id="login-displayname" placeholder="Dad">
        </div>
        <div class="form-group">
            <label class="form-label">GitHub Token (ask Papi for this)</label>
            <input type="password" class="form-input" id="login-token" placeholder="ghp_...">
        </div>
        <button class="btn btn-primary" onclick="app.setupPasskey()">
            <span id="login-btn-text">üîê Create Passkey & Sign In</span>
        </button>
        <button class="btn btn-secondary" onclick="app.loginWithPasskey()">
            Sign In with Existing Passkey
        </button>
        <p id="login-error" style="color:var(--error);font-size:14px;margin-top:12px;display:none"></p>
    </div>
</div>

<!-- Main App -->
<div id="app" class="hide">
    <div class="header">
        <h1>MemoryFreedom</h1>
        <div class="status">
            <div class="dot synced" id="status-dot"></div>
            <span id="status-text">Synced</span>
        </div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="app.switchTab('browse')">Browse</button>
        <button class="tab" onclick="app.switchTab('scan')">Scan</button>
        <button class="tab" onclick="app.switchTab('chat')">Chat</button>
        <button class="tab" onclick="app.switchTab('settings')">Settings</button>
    </div>

    <!-- Browse Tab -->
    <div id="browse" class="content active">
        <div class="search">
            <span>üîç</span>
            <input id="search" placeholder="Search for items..." oninput="app.search()">
        </div>
        <div class="chips" id="chips"></div>
        <div id="items"></div>
        <button class="fab" onclick="app.showAddItem()">+</button>
    </div>

    <!-- Scan Tab -->
    <div id="scan" class="content">
        <div class="empty">
            <div class="empty-icon">üì∑</div>
            <h3 class="empty-title">QR Codes</h3>
            <p class="empty-text">Generate QR codes for your containers</p>
            <button class="btn btn-primary mt" onclick="app.generateQR()">Generate QR Codes</button>
        </div>
    </div>

    <!-- Chat Tab -->
    <div id="chat" class="content">
        <div id="chat-empty" class="empty">
            <div class="empty-icon">üí¨</div>
            <h3 class="empty-title">Chat with Claude</h3>
            <p class="empty-text">Ask about your items</p>
        </div>
        <div id="chat-messages" class="chat hide"></div>
        <div class="chat-input-bar">
            <input id="chat-input" class="chat-input" placeholder="Ask about your items...">
            <button class="chat-send" onclick="app.sendChat()">‚û§</button>
        </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings" class="content">
        <div class="settings-section">
            <h3 class="settings-title">Anthropic API</h3>
            <div class="settings-item">
                <div>
                    <div id="api-status">Not Configured</div>
                    <div style="font-size:12px;color:var(--text2)">For AI chat features</div>
                </div>
                <button class="btn-secondary" style="width:auto;padding:8px 16px;margin:0" onclick="app.showAPIKey()">Configure</button>
            </div>
        </div>
        <div class="settings-section">
            <h3 class="settings-title">Storage</h3>
            <div class="settings-item">
                <span>Total Items</span>
                <span id="total-items">0</span>
            </div>
            <div class="settings-item">
                <span>Categories</span>
                <span id="total-cats">0</span>
            </div>
            <div class="settings-item">
                <div>
                    <div>GitHub Storage</div>
                    <div style="font-size:12px;color:var(--text2)" id="github-info">Loading...</div>
                </div>
            </div>
        </div>
        <div class="settings-section">
            <h3 class="settings-title">Family Members</h3>
            <div id="family-members"></div>
            <button class="btn btn-secondary" onclick="app.showInviteUser()">Invite Family Member</button>
        </div>
        <div class="settings-section">
            <h3 class="settings-title">Maintenance</h3>
            <button class="btn btn-secondary" onclick="app.reload()">
                <span id="reload-text">Reload App Data</span>
            </button>
        </div>
        <div class="settings-section">
            <h3 class="settings-title">Account</h3>
            <div class="settings-item">
                <span>Signed in as</span>
                <span id="current-user-display"></span>
            </div>
            <button class="btn btn-secondary" onclick="app.logout()">Sign Out</button>
        </div>
        <div class="settings-section">
            <h3 class="settings-title">Danger Zone</h3>
            <button class="btn btn-danger" onclick="app.deleteAll()">Delete All Data</button>
        </div>
    </div>
</div>

<!-- Add Item Modal -->
<div id="add-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Add Item</h2>
            <button class="modal-close" onclick="app.closeAddItem()">√ó</button>
        </div>
        <form onsubmit="app.saveItem(event)">
            <div class="form-group">
                <label class="form-label">Item Name *</label>
                <input class="form-input" id="name" required>
            </div>
            <div class="form-group">
                <label class="form-label">Notes (optional)</label>
                <textarea class="form-textarea" id="notes"></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Quantity</label>
                <input type="number" class="form-input" id="qty" value="1" min="1">
            </div>
            <div class="form-group">
                <label class="form-label">Category (Level1 ‚Ä∫ Level2) *</label>
                <input class="form-input" id="category" placeholder="Living room ‚Ä∫ Couch" required>
            </div>
            <div class="form-group">
                <button type="button" class="btn btn-secondary" onclick="app.togglePhoto()">
                    <span id="photo-btn">üì∑ Add Photo (Optional)</span>
                </button>
                <div id="photo-section" class="hide">
                    <input type="file" id="photo" accept="image/*" capture="environment" style="display:none" onchange="app.photoSelected(event)">
                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('photo').click()">Take/Choose Photo</button>
                    <div id="photo-preview" class="hide" style="margin-top:12px">
                        <img id="preview-img" style="width:100%;border-radius:8px">
                    </div>
                </div>
            </div>
            <button type="submit" class="btn btn-primary">Save Item</button>
        </form>
    </div>
</div>

<!-- API Key Modal -->
<div id="api-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Configure API Key</h2>
            <button class="modal-close" onclick="app.closeAPIKey()">√ó</button>
        </div>
        <form onsubmit="app.saveAPIKey(event)">
            <div class="form-group">
                <label class="form-label">Anthropic API Key</label>
                <input type="password" class="form-input" id="api-key" required>
                <p style="font-size:12px;color:var(--text2);margin-top:8px">
                    Get from <a href="https://console.anthropic.com" target="_blank" style="color:var(--accent)">console.anthropic.com</a>
                </p>
            </div>
            <button type="submit" class="btn btn-primary">Save</button>
        </form>
    </div>
</div>

<!-- Invite User Modal -->
<div id="invite-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title">Invite Family Member</h2>
            <button class="modal-close" onclick="app.closeInviteUser()">√ó</button>
        </div>
        
        <div id="invite-form">
            <div class="form-group">
                <label class="form-label">Their Display Name</label>
                <input type="text" class="form-input" id="invite-displayname" placeholder="Mom, Alice, Bob, etc.">
                <p style="font-size:12px;color:var(--text2);margin-top:8px">
                    This will show on items they add
                </p>
            </div>
            <button class="btn btn-primary" onclick="app.generateInvite()">Generate Invite</button>
        </div>

        <div id="invite-result" class="hide">
            <div style="text-align:center;margin-bottom:20px">
                <p style="margin-bottom:12px">Share this QR code or link:</p>
                <div id="invite-qr" style="background:white;display:inline-block;padding:16px;border-radius:8px"></div>
            </div>
            <div class="form-group">
                <label class="form-label">Or share this link:</label>
                <input type="text" class="form-input" id="invite-link" readonly onclick="this.select()">
            </div>
            <button class="btn btn-secondary" onclick="app.copyInviteLink()">Copy Link</button>
            <p style="font-size:12px;color:var(--text2);margin-top:12px">
                They'll need their own GitHub token. The link expires in 24 hours.
            </p>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
<script>
```

const app = {
// Hardcoded config
GITHUB_USERNAME: ‚ÄòRedThero‚Äô,
GITHUB_REPO: ‚Äòmemoryfreedom-storage‚Äô,

```
// State
items: [],
chatMessages: [],
apiKey: null,
selectedCategory: 'All',
searchTerm: '',
currentPhoto: null,
currentUser: null,

// GitHub storage
github: {
    username: 'RedThero',
    token: null,
    repo: 'memoryfreedom-storage',
    displayName: null,
    userKey: null,  // Derived from passkey
    masterKey: null // Shared master key for data
},

// Passkey support
async checkPasskeySupport() {
    return window.PublicKeyCredential !== undefined && 
           typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function' &&
           await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
},

async createPasskey(username, displayName) {
    const challenge = new Uint8Array(32);
    crypto.getRandomValues(challenge);

    const publicKeyOptions = {
        challenge,
        rp: {
            name: "MemoryFreedom",
            id: window.location.hostname
        },
        user: {
            id: new TextEncoder().encode(username),
            name: username,
            displayName: displayName
        },
        pubKeyCredParams: [
            { alg: -7, type: "public-key" },  // ES256
            { alg: -257, type: "public-key" } // RS256
        ],
        authenticatorSelection: {
            authenticatorAttachment: "platform",
            userVerification: "required",
            requireResidentKey: true
        },
        timeout: 60000,
        attestation: "none"
    };

    try {
        const credential = await navigator.credentials.create({
            publicKey: publicKeyOptions
        });

        // Store credential ID and user info
        localStorage.setItem('mf_credential_id', btoa(String.fromCharCode(...new Uint8Array(credential.rawId))));
        localStorage.setItem('mf_username', username);
        localStorage.setItem('mf_displayname', displayName);

        // Use the challenge as entropy for deriving encryption key
        return await this.deriveKeyFromPasskey(challenge);
    } catch (error) {
        console.error('Passkey creation error:', error);
        throw new Error('Failed to create passkey. Make sure your device supports biometrics.');
    }
},

async authenticateWithPasskey() {
    const credentialId = localStorage.getItem('mf_credential_id');
    if (!credentialId) {
        throw new Error('No passkey found on this device');
    }

    const challenge = new Uint8Array(32);
    crypto.getRandomValues(challenge);

    const publicKeyOptions = {
        challenge,
        rpId: window.location.hostname,
        allowCredentials: [{
            id: Uint8Array.from(atob(credentialId), c => c.charCodeAt(0)),
            type: 'public-key'
        }],
        userVerification: "required",
        timeout: 60000
    };

    try {
        const assertion = await navigator.credentials.get({
            publicKey: publicKeyOptions
        });

        // Use the challenge as entropy for deriving encryption key
        return await this.deriveKeyFromPasskey(challenge);
    } catch (error) {
        console.error('Passkey authentication error:', error);
        throw new Error('Authentication failed. Try again.');
    }
},

async deriveKeyFromPasskey(challenge) {
    // Derive a key from the passkey challenge
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        challenge,
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );
    
    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: new TextEncoder().encode('memoryfreedom-v1'),
            iterations: 100000,
            hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
},

async generateMasterKey() {
    return crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
},

async exportKey(key) {
    const exported = await crypto.subtle.exportKey('raw', key);
    return btoa(String.fromCharCode(...new Uint8Array(exported)));
},

async importKey(base64) {
    const keyData = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
    return crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
},

async encryptWithKey(text, key) {
    const enc = new TextEncoder();
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        enc.encode(text)
    );
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);
    return btoa(String.fromCharCode(...combined));
},

async decryptWithKey(base64, key) {
    const combined = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
    const iv = combined.slice(0, 12);
    const data = combined.slice(12);
    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        data
    );
    return new TextDecoder().decode(decrypted);
},

async encrypt(text) {
    return this.encryptWithKey(text, this.github.masterKey);
},

async decrypt(base64) {
    return this.decryptWithKey(base64, this.github.masterKey);
},

async encryptForUser(text) {
    return this.encryptWithKey(text, this.github.userKey);
},

async decryptForUser(base64) {
    return this.decryptWithKey(base64, this.github.userKey);
},

// GitHub API
async githubAPI(path, method = 'GET', body = null) {
    const url = `https://api.github.com/repos/${this.github.username}/${this.github.repo}/${path}`;
    const headers = {
        'Authorization': `token ${this.github.token}`,
        'Accept': 'application/vnd.github.v3+json'
    };
    
    const options = { method, headers };
    if (body) {
        options.body = JSON.stringify(body);
    }

    const response = await fetch(url, options);
    if (!response.ok && response.status !== 404) {
        throw new Error(`GitHub API error: ${response.status}`);
    }
    return response.status === 404 ? null : await response.json();
},

async loadFromGitHub(filename) {
    try {
        const file = await this.githubAPI(`contents/${filename}`);
        if (!file) return null;
        const encrypted = atob(file.content);
        const decrypted = await this.decrypt(encrypted);
        return JSON.parse(decrypted);
    } catch (error) {
        console.error(`Load ${filename} error:`, error);
        return null;
    }
},

async saveToGitHub(filename, data) {
    try {
        const json = JSON.stringify(data);
        const encrypted = await this.encrypt(json);
        const content = btoa(encrypted);

        // Get current file SHA if exists
        let sha = null;
        try {
            const existing = await this.githubAPI(`contents/${filename}`);
            if (existing) sha = existing.sha;
        } catch (e) {}

        // Save file
        await this.githubAPI(`contents/${filename}`, 'PUT', {
            message: `Update ${filename}`,
            content,
            ...(sha && { sha })
        });
    } catch (error) {
        console.error(`Save ${filename} error:`, error);
        throw error;
    }
},

async uploadPhoto(photoData, filename) {
    try {
        // Encrypt the photo data
        const encrypted = await this.encrypt(photoData);
        const content = btoa(encrypted);
        
        // Get SHA if exists
        let sha = null;
        try {
            const existing = await this.githubAPI(`contents/photos/${filename}.enc`);
            if (existing) sha = existing.sha;
        } catch (e) {}

        await this.githubAPI(`contents/photos/${filename}.enc`, 'PUT', {
            message: `Upload photo ${filename}`,
            content,
            ...(sha && { sha })
        });

        // Return the encrypted filename - we'll decrypt on load
        return filename;
    } catch (error) {
        console.error('Photo upload error:', error);
        return null;
    }
},

async loadPhoto(filename) {
    if (!filename) return null;
    try {
        const file = await this.githubAPI(`contents/photos/${filename}.enc`);
        if (!file) return null;
        const encrypted = atob(file.content);
        const decrypted = await this.decrypt(encrypted);
        return decrypted; // Returns the original data:image/jpeg;base64,...
    } catch (error) {
        console.error('Photo load error:', error);
        return null;
    }
},

// Login with new passkey
async setupPasskey() {
    const token = document.getElementById('login-token').value.trim();
    const displayName = document.getElementById('login-displayname').value.trim();

    if (!token || !displayName) {
        this.showLoginError('Please fill in both fields');
        return;
    }

    // Check passkey support
    const supported = await this.checkPasskeySupport();
    if (!supported) {
        this.showLoginError('Your device does not support passkeys. Please use a device with Face ID, Touch ID, or Windows Hello.');
        return;
    }

    document.getElementById('loading-text').textContent = 'Creating passkey...';
    document.getElementById('loading').classList.remove('hide');

    try {
        this.github.token = token;
        this.github.displayName = displayName;
        this.currentUser = displayName;

        // Create passkey and derive user key
        this.github.userKey = await this.createPasskey(this.GITHUB_USERNAME, displayName);

        // Try to create repo
        try {
            await fetch('https://api.github.com/user/repos', {
                method: 'POST',
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                },
                body: JSON.stringify({
                    name: this.GITHUB_REPO,
                    description: 'MemoryFreedom shared family storage',
                    private: true,
                    auto_init: true
                })
            });
        } catch (e) {}

        // Load or create master key
        await this.loadOrCreateMasterKey();

        // Save encrypted master key locally
        await this.saveMasterKeyLocally();

        // Save credentials
        localStorage.setItem('mf_token', token);
        localStorage.setItem('mf_displayname', displayName);

        // Init app
        await this.init();

        document.getElementById('login').classList.add('hide');
        document.getElementById('app').classList.remove('hide');
        document.getElementById('loading').classList.add('hide');

    } catch (error) {
        console.error('Setup error:', error);
        this.showLoginError(error.message || 'Setup failed. Please try again.');
        document.getElementById('loading').classList.add('hide');
    }
},

// Login with existing passkey
async loginWithPasskey() {
    const token = localStorage.getItem('mf_token');
    const displayName = localStorage.getItem('mf_displayname');

    if (!token || !displayName) {
        this.showLoginError('No saved credentials. Please set up a new passkey.');
        return;
    }

    document.getElementById('loading-text').textContent = 'Authenticating...';
    document.getElementById('loading').classList.remove('hide');

    try {
        this.github.token = token;
        this.github.displayName = displayName;
        this.currentUser = displayName;

        // Authenticate with passkey
        this.github.userKey = await this.authenticateWithPasskey();

        // Load master key from local storage
        await this.loadMasterKeyLocally();

        // Init app
        await this.init();

        document.getElementById('login').classList.add('hide');
        document.getElementById('app').classList.remove('hide');
        document.getElementById('loading').classList.add('hide');

    } catch (error) {
        console.error('Login error:', error);
        this.showLoginError(error.message || 'Login failed. Please try again.');
        document.getElementById('loading').classList.add('hide');
    }
},

async saveMasterKeyLocally() {
    const masterKeyBase64 = await this.exportKey(this.github.masterKey);
    const encrypted = await this.encryptForUser(masterKeyBase64);
    localStorage.setItem('mf_master_key', encrypted);
},

async loadMasterKeyLocally() {
    const encrypted = localStorage.getItem('mf_master_key');
    if (!encrypted) {
        throw new Error('No master key found. Please set up again.');
    }
    const masterKeyBase64 = await this.decryptForUser(encrypted);
    this.github.masterKey = await this.importKey(masterKeyBase64);
},

async loadOrCreateMasterKey() {
    // Check if master key exists locally
    const localKey = localStorage.getItem('mf_master_key');
    
    if (localKey) {
        // Load from local storage
        const masterKeyBase64 = await this.decryptForUser(localKey);
        this.github.masterKey = await this.importKey(masterKeyBase64);
        return;
    }

    // Try to load from GitHub
    const userKeyFile = `users/${this.github.displayName}.key`;
    const encryptedMasterKey = await this.loadFromGitHubRaw(userKeyFile);

    if (encryptedMasterKey) {
        // User exists in GitHub - decrypt their copy
        const masterKeyBase64 = await this.decryptForUser(encryptedMasterKey);
        this.github.masterKey = await this.importKey(masterKeyBase64);
        await this.saveMasterKeyLocally();
    } else {
        // Check if other users exist
        const users = await this.listUsers();
        
        if (users.length > 0) {
            throw new Error('You need an invite from an existing family member. Ask them to invite you in Settings.');
        } else {
            // First user - create new master key
            this.github.masterKey = await this.generateMasterKey();
            await this.saveMasterKeyForUser(this.github.displayName);
            await this.saveMasterKeyLocally();
        }
    }
},

async saveMasterKeyForUser(username) {
    // Export master key and encrypt it with user's key
    const masterKeyBase64 = await this.exportKey(this.github.masterKey);
    const encryptedMasterKey = await this.encryptForUser(masterKeyBase64);
    
    // Save to users/[username].key
    const content = btoa(encryptedMasterKey);
    await this.githubAPI(`contents/users/${username}.key`, 'PUT', {
        message: `Add user ${username}`,
        content
    });
},

async listUsers() {
    try {
        const contents = await this.githubAPI('contents/users');
        if (!contents) return [];
        return contents
            .filter(f => f.name.endsWith('.key'))
            .map(f => f.name.replace('.key', ''));
    } catch (e) {
        return [];
    }
},

async loadFromGitHubRaw(path) {
    try {
        const file = await this.githubAPI(`contents/${path}`);
        if (!file) return null;
        return atob(file.content);
    } catch (error) {
        return null;
    }
},

showLoginError(msg) {
    const error = document.getElementById('login-error');
    error.textContent = msg;
    error.style.display = 'block';
},

logout() {
    if (confirm('Sign out? Your data will remain in GitHub.')) {
        localStorage.clear();
        location.reload();
    }
},

// Init
async init() {
    this.updateStatus('Loading...', 'syncing');

    // Load items
    const items = await this.loadFromGitHub('items.json');
    if (items) this.items = items;

    // Load chat
    const chat = await this.loadFromGitHub('chat.json');
    if (chat) this.chatMessages = chat;

    // Load API key (stored encrypted in GitHub)
    const config = await this.loadFromGitHub('config.json');
    if (config && config.apiKey) {
        this.apiKey = config.apiKey;
        document.getElementById('api-status').textContent = 'Configured ‚úì';
    }

    this.updateUI();
    this.updateStatus('Synced', 'synced');

    // Update GitHub info
    document.getElementById('github-info').textContent = `${this.GITHUB_USERNAME}/${this.GITHUB_REPO}`;
},

updateStatus(text, state) {
    document.getElementById('status-text').textContent = text;
    const dot = document.getElementById('status-dot');
    dot.className = `dot ${state}`;
},

updateUI() {
    this.renderItems();
    this.renderCategories();
    this.renderChat();
    this.updateStats();
},

async renderItems() {
    const container = document.getElementById('items');
    let filtered = this.items;

    if (this.selectedCategory !== 'All') {
        filtered = filtered.filter(i => i.category.includes(this.selectedCategory));
    }

    if (this.searchTerm) {
        const term = this.searchTerm.toLowerCase();
        filtered = filtered.filter(i =>
            i.name.toLowerCase().includes(term) ||
            (i.notes && i.notes.toLowerCase().includes(term))
        );
    }

    if (filtered.length === 0) {
        container.innerHTML = `
            <div class="empty">
                <div class="empty-icon">üì¶</div>
                <h3 class="empty-title">No items${this.searchTerm ? ' found' : ' yet'}</h3>
                <p class="empty-text">${this.searchTerm ? 'Try different search' : 'Tap + to add first item'}</p>
            </div>
        `;
        return;
    }

    // Render items with placeholders first
    container.innerHTML = filtered.map(item => `
        <div class="item" onclick="app.viewItem('${item.id}')">
            <div class="item-content">
                <div class="item-img placeholder" id="img-${item.id}">üì∑</div>
                <div class="item-info">
                    <div class="item-name">${item.name}</div>
                    <div class="item-cat">${item.category}</div>
                    ${item.notes ? `<div class="item-notes">${item.notes}</div>` : ''}
                    ${item.quantity > 1 ? `<div class="item-notes">Qty: ${item.quantity}</div>` : ''}
                    ${item.addedBy ? `<div class="item-notes">Added by ${item.addedBy}</div>` : ''}
                </div>
            </div>
        </div>
    `).join('');

    // Load and decrypt photos asynchronously
    for (const item of filtered) {
        if (item.photo) {
            const photoData = await this.loadPhoto(item.photo);
            if (photoData) {
                const imgEl = document.getElementById(`img-${item.id}`);
                if (imgEl) {
                    imgEl.outerHTML = `<img src="${photoData}" class="item-img" id="img-${item.id}">`;
                }
            }
        }
    }
},

renderCategories() {
    const level1 = [...new Set(this.items.map(i => i.category.split(' ‚Ä∫ ')[0]))];
    const chips = document.getElementById('chips');
    
    chips.innerHTML = `
        <div class="chip ${this.selectedCategory === 'All' ? 'active' : ''}" onclick="app.filterCategory('All')">
            All (${this.items.length})
        </div>
        ${level1.map(cat => {
            const count = this.items.filter(i => i.category.includes(cat)).length;
            return `
                <div class="chip ${this.selectedCategory === cat ? 'active' : ''}" onclick="app.filterCategory('${cat}')">
                    ${cat} (${count})
                </div>
            `;
        }).join('')}
    `;
},

renderChat() {
    const container = document.getElementById('chat-messages');
    const empty = document.getElementById('chat-empty');
    
    if (this.chatMessages.length === 0) {
        container.classList.add('hide');
        empty.classList.remove('hide');
        return;
    }

    empty.classList.add('hide');
    container.classList.remove('hide');
    container.innerHTML = this.chatMessages.map(m => `
        <div class="bubble ${m.role}">${m.content}</div>
    `).join('');
    container.scrollTop = container.scrollHeight;
},

updateStats() {
    document.getElementById('total-items').textContent = this.items.length;
    const cats = new Set(this.items.map(i => i.category.split(' ‚Ä∫ ')[0]));
    document.getElementById('total-cats').textContent = cats.size;
    
    // Update current user display
    if (this.currentUser) {
        document.getElementById('current-user-display').textContent = this.currentUser;
    }
    
    // Update family members list
    this.updateFamilyMembers();
},

async updateFamilyMembers() {
    const users = await this.listUsers();
    const container = document.getElementById('family-members');
    
    if (!container) return;
    
    container.innerHTML = users.map(user => `
        <div class="settings-item">
            <span>${user}${user === this.currentUser ? ' (you)' : ''}</span>
        </div>
    `).join('');
},

showInviteUser() {
    document.getElementById('invite-modal').classList.add('show');
    document.getElementById('invite-form').classList.remove('hide');
    document.getElementById('invite-result').classList.add('hide');
    document.getElementById('invite-displayname').value = '';
},

closeInviteUser() {
    document.getElementById('invite-modal').classList.remove('show');
},

async generateInvite() {
    const displayName = document.getElementById('invite-displayname').value.trim();
    if (!displayName) return;

    try {
        this.updateStatus('Generating invite...', 'syncing');

        // Export master key
        const masterKeyBase64 = await this.exportKey(this.github.masterKey);

        // Create invite token (expires in 24h)
        const inviteData = {
            masterKey: masterKeyBase64,
            invitedBy: this.currentUser,
            displayName: displayName,
            expires: Date.now() + (24 * 60 * 60 * 1000)
        };

        // Encode as base64
        const inviteToken = btoa(JSON.stringify(inviteData));
        
        // Create invite link
        const inviteLink = `${window.location.origin}${window.location.pathname}#invite=${inviteToken}`;

        // Generate QR code
        const qrContainer = document.getElementById('invite-qr');
        qrContainer.innerHTML = '';
        await QRCode.toCanvas(qrContainer, inviteLink, { width: 250, margin: 2 });

        // Show result
        document.getElementById('invite-link').value = inviteLink;
        document.getElementById('invite-form').classList.add('hide');
        document.getElementById('invite-result').classList.remove('hide');

        this.updateStatus('Synced', 'synced');

    } catch (error) {
        console.error('Invite error:', error);
        alert('Failed to generate invite');
        this.updateStatus('Error', 'error');
    }
},

copyInviteLink() {
    const link = document.getElementById('invite-link');
    link.select();
    document.execCommand('copy');
    alert('Link copied! Share with your family member.');
},

async acceptInvite(inviteToken) {
    try {
        const inviteData = JSON.parse(atob(inviteToken));

        // Check expiration
        if (Date.now() > inviteData.expires) {
            throw new Error('Invite expired. Ask for a new one.');
        }

        // Import master key
        this.github.masterKey = await this.importKey(inviteData.masterKey);
        this.github.displayName = inviteData.displayName;

        // Show setup with pre-filled display name
        document.getElementById('login-displayname').value = inviteData.displayName;

        alert(`You've been invited by ${inviteData.invitedBy}!\n\nPlease ask Papi for the GitHub token, then create your passkey.`);

    } catch (error) {
        console.error('Accept invite error:', error);
        alert(error.message || 'Invalid invite link');
    }
},

filterCategory(cat) {
    this.selectedCategory = cat;
    this.renderItems();
    this.renderCategories();
},

search() {
    this.searchTerm = document.getElementById('search').value;
    this.renderItems();
},

switchTab(tab) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
    document.getElementById(tab).classList.add('active');
},

showAddItem() {
    document.getElementById('add-modal').classList.add('show');
    document.getElementById('name').value = '';
    document.getElementById('notes').value = '';
    document.getElementById('qty').value = '1';
    document.getElementById('category').value = '';
    document.getElementById('photo-section').classList.add('hide');
    document.getElementById('photo-preview').classList.add('hide');
    this.currentPhoto = null;
},

closeAddItem() {
    document.getElementById('add-modal').classList.remove('show');
},

togglePhoto() {
    document.getElementById('photo-section').classList.toggle('hide');
},

photoSelected(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.currentPhoto = e.target.result;
            document.getElementById('preview-img').src = e.target.result;
            document.getElementById('photo-preview').classList.remove('hide');
        };
        reader.readAsDataURL(file);
    }
},

async saveItem(e) {
    e.preventDefault();
    this.updateStatus('Saving...', 'syncing');

    const item = {
        id: Date.now().toString(),
        name: document.getElementById('name').value,
        notes: document.getElementById('notes').value,
        quantity: parseInt(document.getElementById('qty').value),
        category: document.getElementById('category').value,
        photo: null,
        addedBy: this.currentUser,
        dateAdded: new Date().toISOString(),
        modifiedBy: this.currentUser,
        dateModified: new Date().toISOString()
    };

    // Upload encrypted photo to GitHub if provided
    if (this.currentPhoto) {
        const filename = await this.uploadPhoto(this.currentPhoto, `${item.id}.jpg`);
        item.photo = filename; // Store just the filename, not the full data
    }

    this.items.push(item);
    await this.saveToGitHub('items.json', this.items);
    
    this.updateUI();
    this.closeAddItem();
    this.updateStatus('Synced', 'synced');
},

viewItem(id) {
    const item = this.items.find(i => i.id === id);
    if (!item) return;

    const del = confirm(`"${item.name}"\n\nCategory: ${item.category}\n${item.notes ? 'Notes: ' + item.notes + '\n' : ''}Qty: ${item.quantity}\n\nDelete?`);
    
    if (del) {
        this.items = this.items.filter(i => i.id !== id);
        this.saveToGitHub('items.json', this.items);
        this.updateUI();
    }
},

async generateQR() {
    const level2 = {};
    this.items.forEach(item => {
        const parts = item.category.split(' ‚Ä∫ ');
        if (parts.length >= 2) {
            const key = parts.slice(0, 2).join(' ‚Ä∫ ');
            if (!level2[key]) level2[key] = [];
            level2[key].push(item);
        }
    });

    if (Object.keys(level2).length === 0) {
        alert('No level 2 categories. Use format: "Room ‚Ä∫ Container"');
        return;
    }

    let html = '<div style="padding:20px">';
    
    for (const [cat, items] of Object.entries(level2)) {
        const canvas = document.createElement('canvas');
        const qrData = JSON.stringify({
            type: 'memoryfreedom_category',
            path: cat.split(' ‚Ä∫ '),
            itemCount: items.length,
            version: 1
        });
        
        await QRCode.toCanvas(canvas, qrData, { width: 300, margin: 2 });
        
        html += `
            <div style="background:var(--bg2);border-radius:12px;padding:20px;margin-bottom:20px;text-align:center">
                <h3>${cat}</h3>
                <div style="font-size:14px;color:var(--text2);margin:12px 0">${items.length} items</div>
                <div style="background:white;display:inline-block;padding:16px;border-radius:8px">
                    <img src="${canvas.toDataURL()}" style="width:250px;height:250px">
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    
    const modal = document.createElement('div');
    modal.className = 'modal show';
    modal.innerHTML = `
        <div class="modal-content" style="max-width:600px">
            <div class="modal-header">
                <h2 class="modal-title">QR Codes</h2>
                <button class="modal-close" onclick="this.closest('.modal').remove()">√ó</button>
            </div>
            ${html}
        </div>
    `;
    document.body.appendChild(modal);
},

showAPIKey() {
    document.getElementById('api-modal').classList.add('show');
    if (this.apiKey) {
        document.getElementById('api-key').value = this.apiKey;
    }
},

closeAPIKey() {
    document.getElementById('api-modal').classList.remove('show');
},

async saveAPIKey(e) {
    e.preventDefault();
    this.apiKey = document.getElementById('api-key').value;
    await this.saveToGitHub('config.json', { apiKey: this.apiKey });
    document.getElementById('api-status').textContent = 'Configured ‚úì';
    this.closeAPIKey();
},

async sendChat() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    
    if (!message || !this.apiKey) {
        if (!this.apiKey) alert('Configure API key in Settings first');
        return;
    }

    input.value = '';
    this.chatMessages.push({ role: 'user', content: message });
    this.renderChat();

    let context = 'Inventory:\n';
    const cats = {};
    this.items.forEach(item => {
        const l1 = item.category.split(' ‚Ä∫ ')[0];
        if (!cats[l1]) cats[l1] = [];
        cats[l1].push(item);
    });
    
    for (const [cat, items] of Object.entries(cats)) {
        context += `üìç ${cat}\n`;
        items.forEach(i => {
            context += `  ‚Ä¢ ${i.name}`;
            if (i.quantity > 1) context += ` (${i.quantity})`;
            if (i.notes) context += ` - ${i.notes}`;
            context += `\n`;
        });
    }

    try {
        const res = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': this.apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: 1024,
                system: `You're a helpful MemoryFreedom assistant.\n\n${context}`,
                messages: this.chatMessages.map(m => ({ role: m.role, content: m.content }))
            })
        });

        const data = await res.json();
        if (data.content && data.content[0]) {
            this.chatMessages.push({
                role: 'assistant',
                content: data.content[0].text
            });
            await this.saveToGitHub('chat.json', this.chatMessages);
            this.renderChat();
        }
    } catch (error) {
        console.error('Chat error:', error);
        alert('Chat failed. Check API key.');
    }
},

async reload() {
    document.getElementById('reload-text').textContent = 'Reloading...';
    await this.init();
    document.getElementById('reload-text').textContent = 'Reload App Data';
},

async deleteAll() {
    if (confirm('Delete ALL data from GitHub? Cannot be undone!')) {
        if (confirm('Really delete everything?')) {
            this.items = [];
            this.chatMessages = [];
            await this.saveToGitHub('items.json', []);
            await this.saveToGitHub('chat.json', []);
            this.updateUI();
        }
    }
}
```

};

// Check for invite link
window.addEventListener(‚Äòload‚Äô, async () => {
// Check for invite in URL hash
const hash = window.location.hash;
if (hash.startsWith(‚Äô#invite=‚Äô)) {
const inviteToken = hash.substring(8);
await app.acceptInvite(inviteToken);
window.location.hash = ‚Äò‚Äô; // Clear hash
return;
}

```
// Auto-fill if credentials exist
const token = localStorage.getItem('mf_token');
const displayName = localStorage.getItem('mf_displayname');
const credentialId = localStorage.getItem('mf_credential_id');

if (token && displayName && credentialId) {
    // Has existing passkey - show quick login
    document.getElementById('login-btn-text').textContent = 'üîê Sign In with Passkey';
    document.getElementById('loading').classList.add('hide');
} else {
    document.getElementById('loading').classList.add('hide');
}
```

});

// Pull to refresh
let startY = 0;
document.addEventListener(‚Äòtouchstart‚Äô, e => startY = e.touches[0].pageY);
document.addEventListener(‚Äòtouchmove‚Äô, e => {
if (e.touches[0].pageY - startY > 100 && window.scrollY === 0) {
app.reload();
}
});
</script>

</body>
</html>
